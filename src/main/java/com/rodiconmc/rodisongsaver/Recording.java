package com.rodiconmc.rodisongsaver;

import net.md_5.bungee.api.ChatColor;
import net.md_5.bungee.api.chat.ClickEvent;
import net.md_5.bungee.api.chat.ComponentBuilder;
import org.bukkit.Bukkit;
import org.bukkit.Instrument;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.HandlerList;
import org.bukkit.event.Listener;
import org.bukkit.event.block.NotePlayEvent;
import org.bukkit.event.player.AsyncPlayerChatEvent;
import org.bukkit.event.player.PlayerQuitEvent;
import org.bukkit.plugin.Plugin;
import org.bukkit.scheduler.BukkitTask;

import java.io.*;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

class Recording implements Listener {
    private String name;
    private String fName;
    private Player player;
    private Plugin plugin;
    private BukkitTask ticker;
    private List<List<Note>> notes = new ArrayList<>();
    private String hash = UUID.randomUUID().toString().replace("-", "");

    Recording(String name, String fName, Player player, Plugin plugin) {
        File file = new File(plugin.getDataFolder(), fName + ".nbs");
        try {
            if (!file.createNewFile()) {
                player.sendMessage(ChatColor.RED + "That file already exists.");
                return;
            }
        } catch (IOException e) {
            throw new IOError(e);
        }

        this.name = name;
        this.fName = fName;
        this.player = player;
        this.plugin = plugin;
        Bukkit.getPluginManager().registerEvents(this, plugin);
        player.spigot().sendMessage(new ComponentBuilder("Recording started. ").color(ChatColor.AQUA)
        .append("Click here to stop and save.").bold(true).event(new ClickEvent(ClickEvent.Action.RUN_COMMAND, "stop" + hash))
        .create());

        ticker = Bukkit.getScheduler().runTaskTimer(plugin, this::runTick, 0L, 2L);
    }

    private void runTick() {
        notes.add(new ArrayList<>());
    }

    private void stopRecording() {
        ticker.cancel();
        HandlerList.unregisterAll(this);
        saveFile();
        player.spigot().sendMessage(new ComponentBuilder("Song saved as ").color(ChatColor.AQUA)
        .append(fName + ".nbs").italic(true)
        .create());
    }

    private void saveFile() {
        File file = new File(plugin.getDataFolder(), fName + ".nbs");
        try {
            FileOutputStream fout = new FileOutputStream(file);
            DataOutputStream dout = new DataOutputStream(fout);
            writeHeader(dout);
            writeNotes(dout);
            writeFooter(dout);
            dout.close();


        } catch (IOException e) {
            throw new IOError(e);
        }
    }

    @EventHandler
    private void onLeave(PlayerQuitEvent event) {
        if (event.getPlayer().equals(player)) {
            stopRecording();
        }
    }

    @EventHandler
    private void onEndCommand(AsyncPlayerChatEvent event) {
        if (!event.getPlayer().equals(player)) return;
        if (event.getMessage().equals("stop" + hash)) {
            event.setCancelled(true);
            Bukkit.getScheduler().runTask(plugin, this::stopRecording);
        }
    }

    @EventHandler
    private void onNote(NotePlayEvent event) {
        //noinspection deprecation
        notes.get(notes.size() - 1).add(new Note(getInstrumentInt(event.getInstrument()), (event.getNote().getId() + 33)));
    }

    private short getHeight() {
        int height = 0;
        for (List<Note> tick : notes) {
            if (tick.size() > height) {
                height = tick.size();
            }
        }
        return (short) height;
    }

    private void writeHeader(DataOutputStream dout) throws IOException {
        LeUtil.writeShortLE(dout, (short) notes.size()); //Song Length
        LeUtil.writeShortLE(dout, getHeight()); //Song Height
        LeUtil.writeString(dout, name); //Song Name
        LeUtil.writeString(dout, ""); //Song Author
        LeUtil.writeString(dout, ""); //Original Song Author
        LeUtil.writeString(dout, "Song generated by RodiSongSaver"); //Song Description*/
        LeUtil.writeShortLE(dout, (short) 1000); //Song Tempo (10 t/s)
        dout.write(0b0); //Auto Saving (false)
        dout.write(0b1); //Auto Saving Duration
        dout.write((byte) 4); //Time Signature (4/4 time)
        LeUtil.writeIntLE(dout, 0); //Minutes Spent
        LeUtil.writeIntLE(dout, 0); //Left Clicks
        LeUtil.writeIntLE(dout, 0); //Right Clicks
        LeUtil.writeIntLE(dout, 0); //Blocks Added
        LeUtil.writeIntLE(dout, 0); //Blocks Removed
        LeUtil.writeString(dout, ""); //MIDI/Schematic file name
    }

    private void writeNotes(DataOutputStream dout) throws IOException {
        while (notes.get(0).size() == 0) { //Clear out all empty ticks at beginning
            notes.remove(0);
        }

        short ticksToSkip = 1;
        for (List<Note> tick : notes) {
            if (tick.size() == 0) {
                ticksToSkip++;
                continue;
            }
            LeUtil.writeShortLE(dout, ticksToSkip);
            for (Note note : tick) {
                LeUtil.writeShortLE(dout, (short) 1);
                dout.writeByte((byte) note.getInstrument());
                dout.writeByte((byte) note.getKey());
            }
            LeUtil.writeShortLE(dout, (short) 0); //Last item in tick
            ticksToSkip = 1;
        }
        LeUtil.writeShortLE(dout, (short) 0); //Last tick
    }

    private void writeFooter(DataOutputStream dout) throws IOException {
        int height = getHeight();
        for (int i = 0; i < height; i++) {
            LeUtil.writeString(dout, "");
            dout.writeByte(100);
        }

        dout.writeByte(0);
    }

    private int getInstrumentInt(Instrument i) {
        switch (i) {
            case PIANO:
                return 0;
            case BASS_GUITAR:
                return 1;
            case BASS_DRUM:
                return 2;
            case SNARE_DRUM:
                return 3;
            case STICKS:
                return 4;
            case GUITAR:
                return 5;
            case FLUTE:
                return 6;
            case BELL:
                return 7;
            case CHIME:
                return 8;
            case XYLOPHONE:
                return 8;
        }
        return 0;
    }

}
